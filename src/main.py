import cv2
from cv2 import WINDOW_NORMAL
from ultralytics import YOLO
import math
import torch
import numpy as np
from collections import defaultdict

# --- Globálne konštanty ---
VIDEO_PATH_DEFAULT = "../testvideos/main/ch04_20241022135650.mp4"  # Príklad predvoleného videa
video_path_ch1 = "../testvideos/main/ch01_20241022100000.mp4"
video_path_ch3 = "../testvideos/main/ch03_20241022105505.mp4"
video_path_ch2 = "../testvideos/main/ch02_20241022130405.mp4"
video_path_ch15 = "../testvideos/main/ch15_20241022105615.mp4"
video_path_ch14 = "../testvideos/main/ch14_20241022100000.mp4"
video_path_ch4 = "../testvideos/main/ch04_20241022113541.mp4"
video_path_ch4_2 = "../testvideos/main/ch04_20241022124617.mp4"
video_path_ch4_3 = "../testvideos/main/ch04_20241022135650.mp4"
MODEL_PATH_DEFAULT = "finetunning/runs/detect/train_dV3/weights/best.pt"  # Váš posledný model

FONT = cv2.FONT_HERSHEY_SIMPLEX
FONT_SCALE = 0.9
FONT_THICKNESS = 2
TEXT_COLOR_CONFIDENCE = (0, 255, 0)  # Zelená pre konfidenciu
TEXT_COLOR_TSHIRT = (255, 255, 0)  # Tyrkysová pre farbu trička
TEXT_COLOR_COUNTER = (255, 255, 255)  # Biela pre počítadlá

# Definície farieb a mapovanie HUE (z predchádzajúcej verzie)
COLOR_NAME_MAP = {
    "red": ([170, 179],),  # Červená je na oboch koncoch Hue spektra
    "orange": ([0, 10],),
    "yellow": ([10, 20],),
    "green": ([36, 85],),  # Zelená má často širší rozsah
    "blue": ([90, 130],),  # Upravené pre lepší stred modrej
}
ACHROMATIC_S_THRESHOLD = 80
ACHROMATIC_V_THRESHOLD_DARK = 80
ACHROMATIC_V_THRESHOLD_BRIGHT = 200

# Globálne počítadlo farieb
color_counters = defaultdict(int)


# main logic of this function generated by Gemini 2.5 pro
def get_dominant_color_name(hsv_tshirt_roi, hue_bins=18):
    """
    Analyzuje ROI trička v HSV a vráti názov dominantnej farby,
    spolu s relevantnou hodnotou Hue a priemernou Saturation a Value.
    Vracia: (nazov_farby, hue_hodnota, priemerna_sytost, priemerny_jas)
    """
    if hsv_tshirt_roi.size == 0:
        return "N/A (prázdne ROI)", None, None, None

    avg_s = float(np.mean(hsv_tshirt_roi[:, :, 1]))  # Priemerná sýtosť celej ROI
    avg_v = float(np.mean(hsv_tshirt_roi[:, :, 2]))  # Priemerný jas celej ROI

    # Prahové hodnoty (definujte ich globálne alebo ich odovzdajte funkcii)
    # ACHROMATIC_S_THRESHOLD = 65
    # ACHROMATIC_V_THRESHOLD_DARK = 70
    # ACHROMATIC_V_THRESHOLD_BRIGHT = 200
    if avg_v < ACHROMATIC_V_THRESHOLD_DARK:
        return "black", None, avg_s, avg_v
    # if avg_s < ACHROMATIC_S_THRESHOLD:
    #     return "white", None, avg_s, avg_v

    # Maska pre chromatické farby
    mask = cv2.inRange(hsv_tshirt_roi,
                       np.array([0, ACHROMATIC_S_THRESHOLD, ACHROMATIC_V_THRESHOLD_DARK]),
                       np.array([179, 255, ACHROMATIC_V_THRESHOLD_BRIGHT]))

    if cv2.countNonZero(mask) == 0:
        # Ak maska všetko odfiltruje, stále máme avg_s a avg_v z celej ROI
        return "N/A (maska)", None, avg_s, avg_v

    hist_hue = cv2.calcHist([hsv_tshirt_roi], [0], mask, [hue_bins], [0, 180])
    dominant_hue_bin = np.argmax(hist_hue)
    dominant_hue_value = float((dominant_hue_bin + 0.5) * (180 / hue_bins))

    for color_name, hue_ranges in COLOR_NAME_MAP.items():
        for hue_range in hue_ranges:
            if hue_range[0] <= dominant_hue_value <= hue_range[1]:
                return color_name, dominant_hue_value, avg_s, avg_v

    # Ak sa nenájde zhoda v mape, vrátime vypočítaný Hue
    return f"H:{dominant_hue_value:.0f}", dominant_hue_value, avg_s, avg_v


def draw_color_counters(frame):
    """
    Vykreslí počítadlá farieb v ľavom dolnom rohu okna.
    """
    if not color_counters:
        return frame

    # Pozícia pre začiatok textu (ľavý dolný roh)
    start_x = 10
    start_y = frame.shape[0] - 20  # 20 pixelov od spodku

    # Pozadie pre lepšiu čitateľnosť
    overlay = frame.copy()

    # Výpočet veľkosti pozadia
    text_height = 25
    max_text_width = 0

    # Najprv zistíme najširší text pre pozadie
    for color_name, count in color_counters.items():
        text = f"{color_name}: {count}"
        (text_width, _), _ = cv2.getTextSize(text, FONT, FONT_SCALE, FONT_THICKNESS)
        max_text_width = max(max_text_width, text_width)

    # Vykreslíme pozadie
    bg_height = len(color_counters) * text_height + 10
    cv2.rectangle(overlay, (start_x - 5, start_y - bg_height),
                  (start_x + max_text_width + 10, start_y + 5),
                  (0, 0, 0), -1)

    # Zmiešame s pôvodným frame pre priehľadnosť
    cv2.addWeighted(overlay, 0.7, frame, 0.3, 0, frame)

    # Vykreslíme texty počítadiel
    current_y = start_y - 10
    for color_name, count in sorted(color_counters.items()):
        text = f"{color_name}: {count}"
        cv2.putText(frame, text, (start_x, current_y),
                    FONT, FONT_SCALE , TEXT_COLOR_COUNTER, FONT_THICKNESS)
        current_y -= text_height

    return frame


def perform_yolo_detection(frame, model, device):
    """
    Vykoná YOLO detekciu na snímke a vráti výsledky.
    Filtruje len pre triedu 0 (predpokladáme "osoba").
    """
    results = model.predict(frame, classes=0, device=device, verbose=False)
    return results[0] if results and results[0].boxes else None


def process_and_draw_detections(frame_to_draw_on, yolo_result_object, update_counters=True):
    """
    Spracuje výsledky YOLO detekcie, analyzuje farby tričiek a vykreslí informácie.
    Vráti anotovanú snímku a zoznam dát o farbách vrátane H, S, V.

    Args:
        update_counters (bool): Či aktualizovať globálne počítadlá farieb
    """
    global color_counters

    annotated_frame = frame_to_draw_on.copy()
    color_analysis_output = []
    class_names_map = yolo_result_object.names

    # Pre jeden frame - lokálne počítadlo na aktualizáciu globálneho
    frame_colors = []

    for box_obj in yolo_result_object.boxes:
        x1, y1, x2, y2 = map(int, box_obj.xyxy[0])
        # ... (získanie confidence, class_name ako predtým) ...
        confidence = float(box_obj.conf[0])
        class_name = class_names_map[int(box_obj.cls[0])]

        # Vykreslenie rámčeka osoby a konfidencie (ako predtým)
        cv2.rectangle(annotated_frame, (x1, y1), (x2, y2), (255, 0, 0), 2)
        confidence_text = f"{class_name} {confidence * 100:.0f}%"
        text_y_offset_confidence = -25
        cv2.putText(annotated_frame, confidence_text, (x1, y1 + text_y_offset_confidence),
                    FONT, FONT_SCALE * 0.8, TEXT_COLOR_CONFIDENCE, FONT_THICKNESS)

        person_roi_on_annotated_frame = annotated_frame[y1:y2, x1:x2]  # ROI z frame, kde sa už môže kresliť
        # Pre analýzu farieb je lepšie použiť ROI z pôvodného frame_to_draw_on (pred kreslením naň)
        # alebo ešte lepšie, z pôvodného neanotovaného frame, ak by sa `frame_to_draw_on` už anotoval.
        # V tomto prípade `frame_to_draw_on` je na začiatku kópia pôvodného frame, takže je to OK.
        person_roi_for_color_analysis = frame_to_draw_on[y1:y2, x1:x2]

        tshirt_color_name_str = "ROI Chyba"
        final_hue = None
        final_saturation = None
        final_value = None

        if person_roi_for_color_analysis.size == 0:
            pass  # Premenné už majú chybové hodnoty
        else:
            person_h, person_w = person_roi_for_color_analysis.shape[:2]
            tshirt_y_start = int(person_h * 0.20)
            tshirt_y_end = int(person_h * 0.55)
            tshirt_x_start = int(person_w * 0.15)
            tshirt_x_end = int(person_w * 0.85)

            # Použijeme ROI z `person_roi_for_color_analysis` pre čistú analýzu farieb
            tshirt_roi_pure = person_roi_for_color_analysis[tshirt_y_start:tshirt_y_end, tshirt_x_start:tshirt_x_end]

            if tshirt_roi_pure.size == 0:
                tshirt_color_name_str = "Tričko N/A"
            else:
                hsv_tshirt_roi = cv2.cvtColor(tshirt_roi_pure, cv2.COLOR_BGR2HSV)
                tshirt_color_name_str, final_hue, final_saturation, final_value = get_dominant_color_name(
                    hsv_tshirt_roi)

        # Pridaj farbu do lokálneho zoznamu pre tento frame
        if tshirt_color_name_str not in ["ROI Chyba", "Tričko N/A", "N/A (prázdne ROI)", "N/A (maska)"]:
            frame_colors.append(tshirt_color_name_str)

        color_analysis_output.append({
            "person_bbox": [x1, y1, x2, y2],
            "confidence": confidence,
            "tshirt_color_name": tshirt_color_name_str,  # Premenované pre jasnosť
            "hue": final_hue,
            "saturation": final_saturation,
            "value": final_value  # Pridáme aj Value, môže byť užitočné
        })

        # Vykreslenie rámčeka trička a názvu farby
        abs_tshirt_x1 = x1 + tshirt_x_start
        abs_tshirt_y1 = y1 + tshirt_y_start
        abs_tshirt_x2 = min(x1 + tshirt_x_end, x2)
        abs_tshirt_y3 = min(y1 + tshirt_y_end, y2)  # Oprava preklepu y2 -> y3

        if person_roi_for_color_analysis.size > 0 and tshirt_roi_pure.size > 0:
            cv2.rectangle(annotated_frame, (abs_tshirt_x1, abs_tshirt_y1), (abs_tshirt_x2, abs_tshirt_y3),
                          (0, 255, 255), 2)

        text_y_offset_tshirt = -5
        cv2.putText(annotated_frame, f"Farba: {tshirt_color_name_str}", (x1, y1 + text_y_offset_tshirt),
                    FONT, FONT_SCALE * 0.8, TEXT_COLOR_TSHIRT, FONT_THICKNESS)

    # Aktualizuj globálne počítadlá
    if update_counters:
        # Pre video - aktualizuj každý frame
        color_counters.clear()
        for color in frame_colors:
            color_counters[color] += 1

    # Vykreslí počítadlá na frame
    annotated_frame = draw_color_counters(annotated_frame)

    return annotated_frame, color_analysis_output


def process_single_image(image_path, model_path):
    """
    Načíta jeden obrázok, vykoná detekciu osôb, analyzuje farby tričiek
    a zobrazí výsledok vrátane H, S, V hodnôt.
    """
    global color_counters
    color_counters.clear()  # Resetuj počítadlá pre nový obrázok

    # ... (načítanie modelu a zariadenia ako predtým) ...
    if torch.cuda.is_available():
        device = 'cuda'
    else:
        device = 'cpu'
    print(f"Používa sa zariadenie: {device}")

    try:
        model = YOLO(model_path)
        model.to(device)
        print(f"Model {model_path} úspešne načítaný na {device}.")
    except Exception as e:
        print(f"Chyba pri načítaní modelu {model_path}: {e}")
        return

    frame = cv2.imread(image_path)
    if frame is None:
        print(f"Chyba: Nepodarilo sa načítať obrázok: {image_path}")
        return
    print(f"Obrázok {image_path} úspešne načítaný.")

    yolo_results = perform_yolo_detection(frame, model, device)
    final_frame_to_show = frame.copy()

    if yolo_results:
        final_frame_to_show, color_data_list = process_and_draw_detections(final_frame_to_show,
                                                                           yolo_results, update_counters=True)

        if color_data_list:  # premenoval som color_data na color_data_list
            print(f"--- Výsledky analýzy pre obrázok: {image_path} ---")
            for i, data in enumerate(color_data_list):  # premenoval som color_data na color_data_list
                hue_print = f"{data['hue']:.1f}" if data['hue'] is not None else "N/A"
                sat_print = f"{data['saturation']:.1f}" if data['saturation'] is not None else "N/A"
                val_print = f"{data['value']:.1f}" if data['value'] is not None else "N/A"  # Pridaný výpis Value

                print(f"  Osoba {i + 1} na pozícii {data['person_bbox']}: "
                      f"Farba='{data['tshirt_color_name']}', "
                      f"Hue={hue_print}, Sat={sat_print}, Val={val_print}, "  # Pridaný Val
                      f"Konf={data['confidence']:.2f}")

            # Vypíš počítadlá farieb
            print(f"--- Počítadlá farieb ---")
            for color_name, count in sorted(color_counters.items()):
                print(f"  {color_name}: {count}")
        else:
            print("Na obrázku neboli nájdené žiadne osoby na analýzu farby trička (po spracovaní detekcií).")
    else:
        print(f"Na obrázku {image_path} neboli detegované žiadne osoby (podľa filtra triedy 0).")

    cv2.namedWindow('Analyzovaný obrázok', WINDOW_NORMAL)
    cv2.imshow('Analyzovaný obrázok', final_frame_to_show)
    print("Obrázok sa zobrazuje. Stlačte ľubovoľné tlačidlo pre zatvorenie okna.")
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    print("Zobrazenie obrázka ukončené.")


# --- Hlavná funkcia pre spracovanie videa ---

def main_video_loop(video_path, model_path):
    """
    Hlavná slučka pre načítanie modelu, spracovanie videa snímku po snímke,
    detekciu osôb a analýzu farby ich tričiek.
    """
    global color_counters
    color_counters.clear()  # Resetuj počítadlá na začiatku videa

    if torch.cuda.is_available():
        device = 'cuda'
    else:
        device = 'cpu'
    print(f"Používa sa zariadenie: {device}")

    # Načítanie YOLO modelu
    try:
        model = YOLO(model_path)
        model.to(device)
        print(f"Model {model_path} úspešne načítaný na {device}.")
    except Exception as e:
        print(f"Chyba pri načítaní modelu {model_path}: {e}")
        return

    # Otvorenie video súboru
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print(f"Chyba: Nepodarilo sa otvoriť video súbor: {video_path}")
        return

    original_fps = cap.get(cv2.CAP_PROP_FPS)
    if original_fps == 0:
        print("Varovanie: Nepodarilo sa získať FPS videa. Prehrávanie s predvolenou rýchlosťou (30ms delay).")
        playback_delay_ms = 30
    else:
        # playback_delay_ms = 30
        playback_delay_ms = int(1000 / original_fps)
        print(f"Pôvodné FPS videa: {original_fps:.2f}. Oneskorenie prehrávania: {playback_delay_ms} ms.")

    cv2.namedWindow('Analyzované video', WINDOW_NORMAL)
    frame_idx = 0
    paused = False

    while True:
        if not paused:
            ret, frame = cap.read()
            if not ret:
                print("Koniec videa alebo chyba pri čítaní snímky.")
                break

        # YOLO Detekcia
        yolo_results = perform_yolo_detection(frame, model, device)

        final_frame_to_show = frame.copy()  # Začneme s čistou kópiou aktuálnej snímky

        if yolo_results:
            final_frame_to_show, color_data = process_and_draw_detections(frame, yolo_results, update_counters=True)

            # Výpis dát o farbách (napr. každú sekundu)
            if color_data and (frame_idx % int(original_fps if original_fps > 0 else 30) == 0):
                print(f"--- Snímka {frame_idx} ---")
                for data in color_data:
                    print(
                        f"  Osoba [{data['person_bbox'][0]},{data['person_bbox'][1]}]: Farba trička={data['tshirt_color_name']}, Konf={data['confidence']:.2f}")

                # Vypíš aktuálne počítadlá
                if color_counters:
                    print("  Počítadlá farieb:", dict(color_counters))

        cv2.imshow('Analyzované video', final_frame_to_show)

        key = cv2.waitKey(1 if paused else playback_delay_ms) & 0xFF
        if key == ord('q'):
            print("Ukončujem...")
            break
        elif key == ord('p'):
            paused = not paused
            if paused:
                print("Video pozastavené. Stlač 'p' pre pokračovanie.")
            else:
                print("Video pokračuje.")
        elif key == ord('r'):  # Reset počítadiel
            color_counters.clear()
            print("Počítadlá farieb resetované.")

        if not paused:
            frame_idx += 1

    cap.release()
    cv2.destroyAllWindows()
    print("Spracovanie videa ukončené.")


# --- Spustenie skriptu ---
if __name__ == '__main__':
    # Pre jednoduchosť použijeme predvolené hodnoty definované vyššie
    selected_video_path = video_path_ch15
    # selected_model_path = MODEL_PATH_DEFAULT  # Uistite sa, že cesta k vášmu .pt súboru je správna
    selected_model_path = "../yolos/yolo11m.pt"  # Uistite sa, že cesta k vášmu .pt súboru je správna

    # Prípadne môžete pridať načítanie ciest z argumentov príkazového riadku
    # import argparse
    # parser = argparse.ArgumentParser(description="YOLO detekcia osôb a analýza farby tričiek.")
    # parser.add_argument("--video", type=str, default=VIDEO_PATH_DEFAULT, help="Cesta k video súboru.")
    # parser.add_argument("--model", type=str, default=MODEL_PATH_DEFAULT, help="Cesta k YOLO .pt modelu.")
    # args = parser.parse_args()
    # main_video_loop(args.video, args.model)

    # process_single_image("../obrazky_bc_praca/GetImage.jpeg", "../yolos/yolo11m.pt")
    main_video_loop(selected_video_path, selected_model_path)